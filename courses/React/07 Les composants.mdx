import { Image } from "@chakra-ui/image";
import ChapterHeading from "@/components/mdx/ChapterHeading";
import { MdCheckCircle, MdCancel } from "react-icons/md";

<Slides title="Les Composants" course="Formation React">

<ChapterHeading title="Le rendu" />

---

<SlideHeader slideTitle="Composants : le rendu" />

#### Le rendu 👀️

- Le rendu se fait dans **la méthode render()** du composant de classe ou
  directement dans **le corps d'un composant fonctionnel**
- React (re)render lorsque :

  - Premier rendu du composant
  - Le state du composant est modifié via **this.setState()** ou **useState()**
  - Le composant est appelé **avec de nouvelles props**

---

<SlideHeader slideTitle="Composants : le rendu" />

#### Algorithme de rendu 👀️

- React gère un **Virtual DOM**
- Lors d'une màj, React effectue un différentiel **entre deux arbres de rendu**
- React modifie **uniquement la partie** du DOM nécessaire

---

<SlideHeader slideTitle="Composants : le rendu" />

#### Algorithme de rendu 👀️

<Image src={require("./assets/virtual-dom.png").default.src} />

---

<SlideHeader slideTitle="Composants : re-render" />

#### Composant fonctionnel : re-render ♻️

- Par défaut, un composant fonctionnel se re-render **à chaque fois**
- Depuis React 16.6 on peut demander un re-render uniquement si les props
  changent avec memo() :

```jsx
import React, { memo } from "react";

const UserProfile = memo((props) => {
  return (
    <div>
      {props.username} {props.email}
    </div>
  );
});
```

---

<SlideHeader slideTitle="Composants : re-render" />

#### Composant de classe : re-render ♻️

- Par défaut, un composant de classe se re-render **à chaque fois**
- On peut utiliser **PureComponent** (même comportement que memo())
- On peut contrôler le re-render avec la méthode **shouldComponentUpdate()**

```jsx
import React, { PureComponent } from "react";

class UserProfile extends PureComponent {
  render() {
    return (
      <div>
        {this.props.username} {this.props.email}
      </div>
    );
  }
}
```

---

<SlideHeader slideTitle="Mise en pratique : state & props" />

##### 📐🤓 <b>Mise en pratique :</b> state & props

- Transformer **le composant MessageList** en composant de classe :

  - Ajoutez lui un état (tableau de messages)
  - Affichez autant de composants **MessageItem** qu'il y a de messages
  - Passez le message en props du composant **MessageItem**
  - Pensez à **la validation** des props

- Afficher les props dans le composant **MessageItem**

---

<ChapterHeading title="Composants : les événements" />

---

<SlideHeader slideTitle="Composants : les événements" />

#### Composant de classes : les événements

- En plus d'une méthode de rendu, de props et d'un state, un composant **de
  classe** a
  **[des événements de cycle de vie](https://reactjs.org/docs/react-component.html#the-component-lifecycle)**
  ([diagramme](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)) :

<List fontSize="1em" textAlign="left" m="0.6em 0" paddingLeft="lg">
  <ListItem>🚩️ getDerivedStateFromProps()</ListItem>
  <ListItem>🚩️ componentDidMount()</ListItem>
  <ListItem>🚩️ componentDidUpdate()</ListItem>
  <ListItem>🚩️ componentWillUnmount()</ListItem>
</List>

---

<SlideHeader slideTitle="Composants : les événements" />

#### 🚩️ Événement

#### [getDerivedStateFromProps()](https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops)

- Exécuté avant chaque rendu

---

<SlideHeader slideTitle="Composants : les événements" />

#### 🚩️ Événement

#### [componentDidMount()](https://reactjs.org/docs/react-component.html#componentdidmount)

- Exécuté après le premier rendu
- En général, on charge les données à ce moment (requêtes vers API…)

---

<SlideHeader slideTitle="Composants : les événements" />

#### 🚩️ Événement

#### [componentDidUpdate(prevProps, prevState)](https://reactjs.org/docs/react-component.html#componentdidupdate)

- Exécuté lorsque le state ou les props ont changés
- Exécuté juste **après** la méthode render()

---

<SlideHeader slideTitle="Composants : les événements" />

#### 🚩️ Événement

#### [componentWillUnmount()](https://reactjs.org/docs/react-component.html#componentwillunmount)

- Exécuté juste avant que le composant soit supprimé du DOM

---

<SlideHeader slideTitle="Composants : les événements" />

#### Composant fonctionnel : useEffect

- 🚨 Les lifecycle events n'existent pas dans les composants fonctionnels
- Il faut utiliser le hook
  [useEffect](https://fr.reactjs.org/docs/hooks-effect.html)

<div style={{ fontSize: 24 }}>

```jsx
import React, { useState, useEffect } from "react";

const App = () => {
  const [count, setCount] = useState(0);

  // Similaire à componentDidMount et componentDidUpdate :
  useEffect(() => {
    document.title = `Vous avez cliqué ${count} fois`;
  }, [count]);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>
        Vous avez cliqué {count} fois
      </button>
    </div>
  );
};
```

</div>

---

<SlideHeader slideTitle="Composants : les événements" />

#### Composant fonctionnel : useEffect

- Si aucune dépendance, le hook est exécuté uniquement lors du premier rendu
  (semblable à componentDidMount) :

```jsx
import React, { useState, useEffect } from "react";

const App = () => {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const data = loadMessages();
    setMessages(data);
  }, []);

  return (
    <ul>
      {messages.map((message) => (
        <li>{message.author}</li>
      ))}
    </ul>
  );
};
```

---

<ChapterHeading title="Communication entre composants" />

---

<SlideHeader slideTitle="Communication entre composants" />

#### 🔄 Il existe différents types de relation :

- Composant **parent vers enfant**
  - On utilise les props
- Composant **enfant vers parent**
  - On utilise des callbacks passés en props
- Données **internes** à un composant
  - On utilise le **state**
- Composant **parent vers petit petit petit fils** 👶️
  - On utilise les <s>props</s> Redux ! (cf. jour 2)

---

<SlideHeader slideTitle="Communication entre composants" />

##### ⬇️ Communication <b>parent vers enfant</b>

- Communication via props :

```jsx
import React from "react";

const Profile = ({ username }) => {
  return <h1>Hello {username}!</h1>;
};

const App = () => {
  return (
    <div>
      <Profile username="Tom" />
    </div>
  );
};
```

---

<SlideHeader slideTitle="Communication entre composants" />

##### ⬇️ Communication <b>enfant vers parent</b>

- Communication via callbacks passés en props :

```jsx
const Profile = ({ onUsernameChange }) => {
  return <input onChange={(e) => onUsernameChange(e.target.value)} />;
};

const App = () => {
  const onUsernameChange = (username) => {
    console.log(username);
  };

  return (
    <div>
      <h1>My app</h1>
      <Profile onUsernameChange={onUsernameChange} />
    </div>
  );
};
```

</Slides>
