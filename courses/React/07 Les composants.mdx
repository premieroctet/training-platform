import { Image } from "@chakra-ui/image";
import ChapterHeading from "@/components/mdx/ChapterHeading";
import { MdCheckCircle, MdCancel } from "react-icons/md";

<Slides title="Les Composants" course="Formation React">

<ChapterHeading title="Le rendu" />

---

<SlideHeader slideTitle="Composants : le rendu" />

#### Le rendu ğŸ‘€ï¸

- Le rendu se fait dans **la mÃ©thode render()** du composant de classe ou
  directement dans **le corps d'un composant fonctionnel**
- React (re)render lorsque :

  - Premier rendu du composant
  - Le state du composant est modifiÃ© via **this.setState()** ou **useState()**
  - Le composant est appelÃ© **avec de nouvelles props**

---

<SlideHeader slideTitle="Composants : le rendu" />

#### Algorithme de rendu ğŸ‘€ï¸

- React gÃ¨re un **Virtual DOM**
- Lors d'une mÃ j, React effectue un diffÃ©rentiel **entre deux arbres de rendu**
- React modifie **uniquement la partie** du DOM nÃ©cessaire

---

<SlideHeader slideTitle="Composants : le rendu" />

#### Algorithme de rendu ğŸ‘€ï¸

<Image src={require("./assets/virtual-dom.png").default.src} />

---

<SlideHeader slideTitle="Composants : re-render" />

#### Composant fonctionnel : re-render â™»ï¸

- Par dÃ©faut, un composant fonctionnel se re-render **Ã  chaque fois**
- Depuis React 16.6 on peut demander un re-render uniquement si les props
  changent avec memo() :

```jsx
import React, { memo } from "react";

const UserProfile = memo((props) => {
  return (
    <div>
      {props.username} {props.email}
    </div>
  );
});
```

---

<SlideHeader slideTitle="Composants : re-render" />

#### Composant de classe : re-render â™»ï¸

- Par dÃ©faut, un composant de classe se re-render **Ã  chaque fois**
- On peut utiliser **PureComponent** (mÃªme comportement que memo())
- On peut contrÃ´ler le re-render avec la mÃ©thode **shouldComponentUpdate()**

```jsx
import React, { PureComponent } from "react";

class UserProfile extends PureComponent {
  render() {
    return (
      <div>
        {this.props.username} {this.props.email}
      </div>
    );
  }
}
```

---

<SlideHeader slideTitle="Mise en pratique : state & props" />

##### ğŸ“ğŸ¤“ <b>Mise en pratique :</b> state & props

- Transformer **le composant MessageList** en composant de classe :

  - Ajoutez lui un Ã©tat (tableau de messages)
  - Affichez autant de composants **MessageItem** qu'il y a de messages
  - Passez le message en props du composant **MessageItem**
  - Pensez Ã  **la validation** des props

- Afficher les props dans le composant **MessageItem**

---

<ChapterHeading title="Composants : les Ã©vÃ©nements" />

---

<SlideHeader slideTitle="Composants : les Ã©vÃ©nements" />

#### Composant de classes : les Ã©vÃ©nements

- En plus d'une mÃ©thode de rendu, de props et d'un state, un composant **de
  classe** a
  **[des Ã©vÃ©nements de cycle de vie](https://reactjs.org/docs/react-component.html#the-component-lifecycle)**
  ([diagramme](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)) :

<List fontSize="1em" textAlign="left" m="0.6em 0" paddingLeft="lg">
  <ListItem>ğŸš©ï¸ getDerivedStateFromProps()</ListItem>
  <ListItem>ğŸš©ï¸ componentDidMount()</ListItem>
  <ListItem>ğŸš©ï¸ componentDidUpdate()</ListItem>
  <ListItem>ğŸš©ï¸ componentWillUnmount()</ListItem>
</List>

---

<SlideHeader slideTitle="Composants : les Ã©vÃ©nements" />

#### ğŸš©ï¸ Ã‰vÃ©nement

#### [getDerivedStateFromProps()](https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops)

- ExÃ©cutÃ© avant chaque rendu

---

<SlideHeader slideTitle="Composants : les Ã©vÃ©nements" />

#### ğŸš©ï¸ Ã‰vÃ©nement

#### [componentDidMount()](https://reactjs.org/docs/react-component.html#componentdidmount)

- ExÃ©cutÃ© aprÃ¨s le premier rendu
- En gÃ©nÃ©ral, on charge les donnÃ©es Ã  ce moment (requÃªtes vers APIâ€¦)

---

<SlideHeader slideTitle="Composants : les Ã©vÃ©nements" />

#### ğŸš©ï¸ Ã‰vÃ©nement

#### [componentDidUpdate(prevProps, prevState)](https://reactjs.org/docs/react-component.html#componentdidupdate)

- ExÃ©cutÃ© lorsque le state ou les props ont changÃ©s
- ExÃ©cutÃ© juste **aprÃ¨s** la mÃ©thode render()

---

<SlideHeader slideTitle="Composants : les Ã©vÃ©nements" />

#### ğŸš©ï¸ Ã‰vÃ©nement

#### [componentWillUnmount()](https://reactjs.org/docs/react-component.html#componentwillunmount)

- ExÃ©cutÃ© juste avant que le composant soit supprimÃ© du DOM

---

<SlideHeader slideTitle="Composants : les Ã©vÃ©nements" />

#### Composant fonctionnel : useEffect

- ğŸš¨ Les lifecycle events n'existent pas dans les composants fonctionnels
- Il faut utiliser le hook
  [useEffect](https://fr.reactjs.org/docs/hooks-effect.html)

<div style={{Â fontSize: 24 }}>

```jsx
import React, { useState, useEffect } from "react";

const App = () => {
  const [count, setCount] = useState(0);

  // Similaire Ã  componentDidMount et componentDidUpdate :
  useEffect(() => {
    document.title = `Vous avez cliquÃ© ${count} fois`;
  }, [count]);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>
        Vous avez cliquÃ© {count} fois
      </button>
    </div>
  );
};
```

</div>

---

<SlideHeader slideTitle="Composants : les Ã©vÃ©nements" />

#### Composant fonctionnel : useEffect

- Si aucune dÃ©pendance, le hook est exÃ©cutÃ© uniquement lors du premier rendu
  (semblable Ã  componentDidMount) :

```jsx
import React, { useState, useEffect } from "react";

const App = () => {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const data = loadMessages();
    setMessages(data);
  }, []);

  return (
    <ul>
      {messages.map((message) => (
        <li>{message.author}</li>
      ))}
    </ul>
  );
};
```

---

<ChapterHeading title="Communication entre composants" />

---

<SlideHeader slideTitle="Communication entre composants" />

#### ğŸ”„ Il existe diffÃ©rents types de relation :

- Composant **parent vers enfant**
  - On utilise les props
- Composant **enfant vers parent**
  - On utilise des callbacks passÃ©s en props
- DonnÃ©es **internes** Ã  un composant
  - On utilise le **state**
- Composant **parent vers petit petit petit fils** ğŸ‘¶ï¸
  - On utilise les <s>props</s> Redux ! (cf. jour 2)

---

<SlideHeader slideTitle="Communication entre composants" />

##### â¬‡ï¸ Communication <b>parent vers enfant</b>

- Communication via props :

```jsx
import React from "react";

const Profile = ({ username }) => {
  return <h1>Hello {username}!</h1>;
};

const App = () => {
  return (
    <div>
      <Profile username="Tom" />
    </div>
  );
};
```

---

<SlideHeader slideTitle="Communication entre composants" />

##### â¬‡ï¸ Communication <b>enfant vers parent</b>

- Communication via callbacks passÃ©s en props :

```jsx
const Profile = ({ onUsernameChange }) => {
  return <input onChange={(e) => onUsernameChange(e.target.value)} />;
};

const App = () => {
  const onUsernameChange = (username) => {
    console.log(username);
  };

  return (
    <div>
      <h1>My app</h1>
      <Profile onUsernameChange={onUsernameChange} />
    </div>
  );
};
```

</Slides>
