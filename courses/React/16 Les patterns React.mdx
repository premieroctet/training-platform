import { Image } from "@chakra-ui/image";
import { Stack } from "@chakra-ui/layout";
import ChapterHeading from "@/components/mdx/ChapterHeading";
import { MdCheckCircle, MdCancel } from "react-icons/md";

<Slides title="Les patterns React" course="Formation React">

<ChapterHeading title="Les patterns React" />

---

###### <b>Component with children</b>

---

<SlideHeader slideTitle="Component with children" />

#### On peut inclure un composant dans un autre

- Gr√¢ce √† la props <b>this.props.children</b> (interne √† React)

```jsx
const ComponentWithHeader = (props) => (
  <div>
    <header>My header</header>
    <section>{this.props.children}</section>
  </div>
);

const App = () => (
  <ComponentWithHeader>
    <p>Hello :)</p>
  </ComponentWithHeader>
);
render(<App />, document.getElementById("root"));
```

---

###### <b>Composants container / pr√©sentation</b>

---

<SlideHeader slideTitle="Composants container et de pr√©sentation" />

#### S√©parer les composants en deux cat√©gories:

- Composants **container**
  - **Data-fetching**
  - Li√©s aux donn√©es et aux actions possibles
- Composants de **pr√©sentation**
  - **Rendering**
  - Affichage et style, ils re√ßoivent des donn√©es et des fonctions en props

---

<SlideHeader slideTitle="Composants container" />

#### Caract√©ristiques d'un composant container:

- D√©finit **comment on r√©cup√®re les donn√©es**
- Pas/peu de **markup JSX**. Pas de styles.
- Fournit **les donn√©es** aux composants de pr√©sentation

---

<SlideHeader slideTitle="Exemple de container" />

```jsx
class CommentListContainer extends React.Component {
  constructor() {
    super();
    this.state = { comments: [] };
  }
  componentDidMount() {
    fetch("/comments")
      .then((resp) => resp.json())
      .then((comments) => {
        this.setState({ comments: comments });
      });
  }
  render() {
    return <CommentList comments={this.state.comments} />;
  }
}
```

---

<SlideHeader slideTitle="Composant de pr√©sentation" />

#### Caract√©ristiques d'un composant de pr√©sentation:

- D√©finit **l'aspect esth√©tique**
- **Peu de d√©pendances** avec l'application
- Ne renseigne pas sur **le moyen de r√©cup√©ration** des donn√©es
- Re√ßoit les donn√©es uniquement **par les props**
- Composant souvent **stateless**

---

<SlideHeader slideTitle="Exemple d'un composant de pr√©sentation" />

```jsx
export default CommentList = (props) => {
  <ul>
    {props.comments.map(({ body, author }) => (
      <li>
        {body}‚Äî{author}
      </li>
    ))}
  </ul>;
};
```

---

<SlideHeader slideTitle="Composants container et de pr√©sentation" />

#### B√©n√©fices de ce motif de conception:

<List fontSize="1em" textAlign="left" m="0.6em 0" padding="12px 0">
  <ListItem>
    <ListIcon as={MdCheckCircle} color="green.300" />
    S√©paration des couches (donn√©es/rendu)
  </ListItem>
  <ListItem>
    <ListIcon as={MdCheckCircle} color="green.300" />
    R√©utilisation des composants de pr√©sentation
  </ListItem>
  <ListItem>
    <ListIcon as={MdCheckCircle} color="green.300" />
    Evite la duplication des composants
  </ListItem>
</List>

---

<SlideHeader slideTitle="Container/Pr√©sentation: r√©sum√©" />

<Stack flexDirection="row" justifyContent="stretch" fontSize="0.6em">
<div width="50%">

#### Container

- Comment les choses **marchent**
- **Connait** l'architecture de l'app
- S'occupe de la **r√©cup√©ration des donn√©es**

</div>
<div width="50%">

#### Pr√©sentation

- Comment les choses **s'affichent**
- Isol√©
- **Affiche** les donn√©es
- R√©utilisable

</div>
</Stack>

---

<SlideHeader slideTitle="Mise en pratique : container" />

##### üìêü§ì <b>Containers</b> : mise en pratique

- S√©parer le composant **MessageList** en deux composants:
  - Un container qui g√®re la liaison avec Redux
  - Un composant de pr√©sentation avec essentiellement du JSX / CSS

---

###### <b>Higher-order components</b>

---

<SlideHeader slideTitle="Higher-order components" />

#### Les Higher-order components (HOC) ‚ú®

- C'est un pattern permettant de rendre les composants **plus modulaires**
- Permet de wrapper un composant dans un autre pour le "d√©corer"
- C'est le principe de **composition**

---

<SlideHeader slideTitle="Higher-order components : exemple" />

```jsx
const makeToggleable = (WrappedComponent) => {
  return class ToggleableComponent extends Component {
    constructor(props) {
      super(props);
      this.state = { toggled: true };
    }

    render() {
      return (
        <div>
          <button
            onClick={() => this.setState({ toggled: !this.state.toggled })}
          >
            {this.state.toggled ? "Masquer" : "Afficher"}
          </button>
          {this.state.toggled && <WrappedComponent {...this.props} />}
        </div>
      );
    }
  };
};

export default makeToggleable;
// Utilisation: makeToggleable(MyComponent)
```

---

<SlideHeader slideTitle="React patterns : lecture" />

##### **React patterns :** un peu de lecture üìö

- Container -
  [Presentational and Container Components](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)
- FaCC -
  [Function as Child Components](https://medium.com/merrickchristensen/function-as-child-components-5f3920a9ace9)
- HOC -
  [React Higher Order Components in depth](https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e)

</Slides>
